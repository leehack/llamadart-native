name: Native Build & Release

on:
  workflow_dispatch:
    inputs:
      llama_cpp_tag:
        description: 'llama.cpp ref to build (e.g., b8011, latest, submodule)'
        required: true
        default: 'submodule'
      publish_release:
        description: 'Publish GitHub release'
        required: true
        default: true
        type: boolean

permissions:
  contents: write

env:
  CMAKE_C_COMPILER_LAUNCHER: ccache
  CMAKE_CXX_COMPILER_LAUNCHER: ccache

jobs:
  resolve-tag:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.tag.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Resolve llama.cpp tag
        id: tag
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ github.event.inputs.llama_cpp_tag }}"

          if [ -z "$TAG" ] || [ "$TAG" = "latest" ]; then
            TAG=$(gh api repos/ggml-org/llama.cpp/releases/latest --jq '.tag_name')
          elif [ "$TAG" = "submodule" ]; then
            TAG=$(git -C third_party/llama.cpp describe --tags --exact-match 2>/dev/null || git -C third_party/llama.cpp rev-parse --short HEAD)
          fi

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "Resolved tag: $TAG"

  build-android:
    needs: resolve-tag
    runs-on: ubuntu-latest
    env:
      CCACHE_DIR: ${{ github.workspace }}/.ccache
      CCACHE_MAXSIZE: 2G
    strategy:
      fail-fast: false
      matrix:
        include:
          - android_abi: arm64-v8a
            out_arch: arm64
          - android_abi: x86_64
            out_arch: x64
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Checkout llama.cpp ref
        if: ${{ github.event.inputs.llama_cpp_tag != 'submodule' }}
        run: |
          TAG="${{ needs.resolve-tag.outputs.tag }}"
          git -C third_party/llama.cpp fetch --tags --force origin
          git -C third_party/llama.cpp checkout --detach "$TAG"
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
      - name: Setup Android SDK/NDK
        uses: android-actions/setup-android@v3
      - name: Install build deps
        run: sudo apt-get update && sudo apt-get install -y ninja-build ccache
      - name: Restore ccache
        uses: actions/cache@v4
        with:
          path: ${{ env.CCACHE_DIR }}
          key: ccache-android-${{ matrix.android_abi }}-${{ github.run_id }}
          restore-keys: |
            ccache-android-${{ matrix.android_abi }}-
      - name: Prime ccache
        run: |
          mkdir -p "${CCACHE_DIR}"
          ccache --max-size "${CCACHE_MAXSIZE}"
          ccache --zero-stats
      - name: Build
        run: python3 tools/build.py android --abi ${{ matrix.android_abi }}
      - name: ccache stats
        if: always()
        run: ccache --show-stats
      - name: Validate Android backend artifacts
        run: |
          OUT_DIR="bin/android/${{ matrix.out_arch }}"
          test -f "$OUT_DIR/libggml-vulkan.so" || { echo "Missing $OUT_DIR/libggml-vulkan.so"; exit 1; }
          test -f "$OUT_DIR/libggml-opencl.so" || { echo "Missing $OUT_DIR/libggml-opencl.so"; exit 1; }
      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: native_android_${{ matrix.android_abi }}
          path: bin/android/${{ matrix.out_arch }}/*

  build-apple:
    needs: resolve-tag
    runs-on: macos-latest
    env:
      CCACHE_DIR: ${{ github.workspace }}/.ccache
      CCACHE_MAXSIZE: 2G
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: macos-arm64
            out_dir: macos/arm64
          - target: macos-x86_64
            out_dir: macos/x86_64
          - target: ios-device-arm64
            out_dir: ios/arm64
          - target: ios-sim-arm64
            out_dir: ios/arm64-sim
          - target: ios-sim-x86_64
            out_dir: ios/x86_64-sim
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Checkout llama.cpp ref
        if: ${{ github.event.inputs.llama_cpp_tag != 'submodule' }}
        run: |
          TAG="${{ needs.resolve-tag.outputs.tag }}"
          git -C third_party/llama.cpp fetch --tags --force origin
          git -C third_party/llama.cpp checkout --detach "$TAG"
      - name: Install build deps
        run: brew install ccache
      - name: Restore ccache
        uses: actions/cache@v4
        with:
          path: ${{ env.CCACHE_DIR }}
          key: ccache-apple-${{ matrix.target }}-${{ github.run_id }}
          restore-keys: |
            ccache-apple-${{ matrix.target }}-
      - name: Prime ccache
        run: |
          mkdir -p "${CCACHE_DIR}"
          ccache --max-size "${CCACHE_MAXSIZE}"
          ccache --zero-stats
      - name: Build
        run: python3 tools/build.py apple --target ${{ matrix.target }}
      - name: ccache stats
        if: always()
        run: ccache --show-stats
      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: native_apple_${{ matrix.target }}
          path: bin/${{ matrix.out_dir }}/*

  build-linux:
    needs: resolve-tag
    runs-on: ubuntu-latest
    env:
      CCACHE_DIR: ${{ github.workspace }}/.ccache
      CCACHE_MAXSIZE: 2G
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
          - arch: arm64
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Checkout llama.cpp ref
        if: ${{ github.event.inputs.llama_cpp_tag != 'submodule' }}
        run: |
          TAG="${{ needs.resolve-tag.outputs.tag }}"
          git -C third_party/llama.cpp fetch --tags --force origin
          git -C third_party/llama.cpp checkout --detach "$TAG"
      - name: Install build deps
        run: |
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            sudo dpkg --add-architecture arm64
            source /etc/os-release
            CODENAME="${VERSION_CODENAME}"
            {
              printf '%s\n' \
                "Types: deb" \
                "URIs: http://archive.ubuntu.com/ubuntu" \
                "Suites: ${CODENAME} ${CODENAME}-updates ${CODENAME}-backports" \
                "Components: main universe restricted multiverse" \
                "Architectures: amd64" \
                "Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg" \
                "" \
                "Types: deb" \
                "URIs: http://security.ubuntu.com/ubuntu" \
                "Suites: ${CODENAME}-security" \
                "Components: main universe restricted multiverse" \
                "Architectures: amd64" \
                "Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg" \
                "" \
                "Types: deb" \
                "URIs: http://ports.ubuntu.com/ubuntu-ports" \
                "Suites: ${CODENAME} ${CODENAME}-updates ${CODENAME}-backports ${CODENAME}-security" \
                "Components: main universe restricted multiverse" \
                "Architectures: arm64" \
                "Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg"
            } | sudo tee /etc/apt/sources.list.d/ubuntu.sources >/dev/null
          fi
          sudo apt-get update
          sudo apt-get install -y ccache ninja-build pkg-config libvulkan-dev glslc make
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu libopenblas-dev:arm64 libvulkan-dev:arm64
          else
            sudo apt-get install -y libopenblas-dev
          fi
          if [ "${{ matrix.arch }}" = "x64" ]; then
            sudo apt-get install -y nvidia-cuda-toolkit
          fi
      - name: Restore ccache
        uses: actions/cache@v4
        with:
          path: ${{ env.CCACHE_DIR }}
          key: ccache-linux-${{ matrix.arch }}-${{ github.run_id }}
          restore-keys: |
            ccache-linux-${{ matrix.arch }}-
      - name: Prime ccache
        run: |
          mkdir -p "${CCACHE_DIR}"
          ccache --max-size "${CCACHE_MAXSIZE}"
          ccache --zero-stats
      - name: Build
        run: python3 tools/build.py linux --arch "${{ matrix.arch }}"
      - name: ccache stats
        if: always()
        run: ccache --show-stats
      - name: Validate Linux backend artifacts
        run: |
          OUT_DIR="bin/linux/${{ matrix.arch }}"
          test -f "$OUT_DIR/libggml-vulkan.so" || { echo "Missing $OUT_DIR/libggml-vulkan.so"; exit 1; }
          find "$OUT_DIR" -maxdepth 1 -type f -name 'libggml-blas.so*' | grep -q . || { echo "Missing BLAS backend in $OUT_DIR"; exit 1; }
          if [ "${{ matrix.arch }}" = "x64" ]; then
            find "$OUT_DIR" -maxdepth 1 -type f -name 'libggml-cuda.so*' | grep -q . || { echo "Missing CUDA backend in $OUT_DIR"; exit 1; }
          fi
      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: native_linux_${{ matrix.arch }}
          path: bin/linux/${{ matrix.arch }}/*

  build-windows:
    needs: resolve-tag
    runs-on: windows-latest
    env:
      CMAKE_C_COMPILER_LAUNCHER: sccache
      CMAKE_CXX_COMPILER_LAUNCHER: sccache
      CMAKE_CUDA_COMPILER_LAUNCHER: sccache
      VCPKG_BINARY_SOURCES: clear;x-gha,readwrite
      VCPKG_FEATURE_FLAGS: binarycaching
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            vcpkg_triplet: x64-windows
          - arch: arm64
            vcpkg_triplet: arm64-windows
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Enable Git Long Paths
        run: git config --global core.longpaths true
      - name: Setup MSVC (x64)
        if: ${{ matrix.arch == 'x64' }}
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64
      - name: Setup MSVC (arm64 cross)
        if: ${{ matrix.arch == 'arm64' }}
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: amd64_arm64
      - name: Checkout llama.cpp ref
        if: ${{ github.event.inputs.llama_cpp_tag != 'submodule' }}
        shell: bash
        run: |
          TAG="${{ needs.resolve-tag.outputs.tag }}"
          git -C third_party/llama.cpp fetch --tags --force origin
          git -C third_party/llama.cpp checkout --detach "$TAG"
      - name: Install Ninja
        run: choco install ninja -y
      - name: Detect preinstalled CUDA Toolkit
        if: ${{ matrix.arch == 'x64' }}
        id: detect_cuda
        run: |
          $nvcc = $null
          $cmd = Get-Command nvcc.exe -ErrorAction SilentlyContinue
          if ($cmd) {
            $nvcc = $cmd.Source
          }
          if (-not $nvcc) {
            $candidates = Get-ChildItem "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA" -Directory -ErrorAction SilentlyContinue |
              Sort-Object Name -Descending |
              ForEach-Object { Join-Path $_.FullName "bin\nvcc.exe" }
            $nvcc = $candidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          }
          if ($nvcc) {
            $cudaBin = Split-Path $nvcc -Parent
            Add-Content $env:GITHUB_PATH $cudaBin
            Add-Content $env:GITHUB_ENV "CUDA_PATH=$(Split-Path $cudaBin -Parent)"
            Add-Content $env:GITHUB_OUTPUT "found=true"
            Write-Host "Using preinstalled CUDA: $nvcc"
            & $nvcc --version
          } else {
            Add-Content $env:GITHUB_OUTPUT "found=false"
            Write-Host "No preinstalled CUDA detected."
          }
      - name: Install CUDA Toolkit
        if: ${{ matrix.arch == 'x64' && steps.detect_cuda.outputs.found != 'true' }}
        run: choco install cuda -y --no-progress --limit-output
      - name: Register CUDA in PATH
        if: ${{ matrix.arch == 'x64' }}
        run: |
          $cudaBin = Get-ChildItem "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA" -Directory -ErrorAction SilentlyContinue |
            Sort-Object Name -Descending |
            ForEach-Object { Join-Path $_.FullName "bin" } |
            Where-Object { Test-Path (Join-Path $_ "nvcc.exe") } |
            Select-Object -First 1
          if (-not $cudaBin) {
            throw "nvcc.exe not found after CUDA install"
          }
          Add-Content $env:GITHUB_PATH $cudaBin
          Add-Content $env:GITHUB_ENV "CUDA_PATH=$(Split-Path $cudaBin -Parent)"
          & (Join-Path $cudaBin "nvcc.exe") --version
      - name: Restore vcpkg cache
        uses: actions/cache@v4
        with:
          path: |
            C:\vcpkg\downloads
            C:\vcpkg\packages
            C:\vcpkg\installed
          key: vcpkg-${{ matrix.vcpkg_triplet }}-${{ github.run_id }}
          restore-keys: |
            vcpkg-${{ matrix.vcpkg_triplet }}-
      - name: Install OpenBLAS (vcpkg)
        run: |
          $vcpkgRoot = "C:\vcpkg"
          if (-not (Test-Path $vcpkgRoot)) {
            git clone https://github.com/microsoft/vcpkg "$vcpkgRoot"
          }
          if (-not (Test-Path "$vcpkgRoot\vcpkg.exe")) {
            & "$vcpkgRoot\bootstrap-vcpkg.bat" -disableMetrics
          }
          & "$vcpkgRoot\vcpkg.exe" install "openblas:${{ matrix.vcpkg_triplet }}"
          & "$vcpkgRoot\vcpkg.exe" install "pkgconf:x64-windows"
          $pkgconfCandidates = @(
            (Join-Path $vcpkgRoot "installed\x64-windows\tools\pkgconf\pkg-config.exe"),
            (Join-Path $vcpkgRoot "installed\x64-windows\tools\pkgconf\pkgconf.exe")
          )
          $pkgconf = $pkgconfCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $pkgconf) {
            throw "pkg-config executable not found in vcpkg tools"
          }
          Add-Content $env:GITHUB_PATH (Split-Path $pkgconf -Parent)
          Add-Content $env:GITHUB_ENV "PKG_CONFIG_EXECUTABLE=$pkgconf"
          Add-Content $env:GITHUB_ENV "VCPKG_ROOT=$vcpkgRoot"
      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.9
      - name: Configure sccache
        run: |
          echo "SCCACHE_GHA_ENABLED=true" >> $env:GITHUB_ENV
      - name: Install Vulkan SDK
        run: |
          $ver = "1.4.313.2"
          curl.exe -o $env:RUNNER_TEMP/VulkanSDK-Installer.exe -L "https://sdk.lunarg.com/sdk/download/$ver/windows/vulkansdk-windows-X64-$ver.exe"
          & "$env:RUNNER_TEMP\VulkanSDK-Installer.exe" --accept-licenses --default-answer --confirm-command install
          Add-Content $env:GITHUB_ENV "VULKAN_SDK=C:\VulkanSDK\$ver"
          Add-Content $env:GITHUB_PATH "C:\VulkanSDK\$ver\Bin"
      - name: Build
        run: python tools/build.py windows --arch ${{ matrix.arch }}
      - name: Validate Windows backend artifacts
        run: |
          $out = "bin/windows/${{ matrix.arch }}"
          if (-not (Get-ChildItem $out -Filter "*ggml-vulkan*.dll" -ErrorAction SilentlyContinue | Select-Object -First 1)) {
            throw "Missing Vulkan backend DLL in $out"
          }
          if (-not (Get-ChildItem $out -Filter "*ggml-blas*.dll" -ErrorAction SilentlyContinue | Select-Object -First 1)) {
            throw "Missing BLAS backend DLL in $out"
          }
          if ("${{ matrix.arch }}" -eq "x64") {
            if (-not (Get-ChildItem $out -Filter "*ggml-cuda*.dll" -ErrorAction SilentlyContinue | Select-Object -First 1)) {
              throw "Missing CUDA backend DLL in $out"
            }
          } else {
            $cache = "build/windows-arm64-full/CMakeCache.txt"
            if (-not (Test-Path $cache)) {
              throw "Missing CMake cache at $cache"
            }
            if (-not (Select-String -Path $cache -Pattern '^GGML_CPU_KLEIDIAI:BOOL=ON$' -Quiet)) {
              throw "Kleidi is not enabled in windows arm64 build"
            }
          }
      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: native_windows_${{ matrix.arch }}
          path: bin/windows/${{ matrix.arch }}/*

  package-and-release:
    needs: [resolve-tag, build-android, build-apple, build-linux, build-windows]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      - name: Prepare release assets
        run: |
          mkdir -p release_assets

          rename_with_suffix() {
            local base="$1"
            local platform="$2"
            local arch="$3"

            case "$base" in
              *.dylib)
                echo "${base%.dylib}-${platform}-${arch}.dylib"
                ;;
              *.dll)
                echo "${base%.dll}-${platform}-${arch}.dll"
                ;;
              *.so)
                echo "${base%.so}-${platform}-${arch}.so"
                ;;
              *.so.*)
                local prefix="${base%%.so*}"
                local rest="${base#${prefix}}"
                echo "${prefix}-${platform}-${arch}${rest}"
                ;;
              *)
                echo "${base}-${platform}-${arch}"
                ;;
            esac
          }

          for dir in artifacts/native_*; do
            [ -d "$dir" ] || continue
            name="$(basename "$dir")"

            platform=""
            arch=""
            case "$name" in
              native_windows_x64)
                platform="windows"; arch="x64" ;;
              native_windows_arm64)
                platform="windows"; arch="arm64" ;;
              native_linux_x64)
                platform="linux"; arch="x64" ;;
              native_linux_arm64)
                platform="linux"; arch="arm64" ;;
              native_apple_macos-arm64)
                platform="macos"; arch="arm64" ;;
              native_apple_macos-x86_64)
                platform="macos"; arch="x86_64" ;;
              native_apple_ios-device-arm64)
                platform="ios"; arch="arm64" ;;
              native_apple_ios-sim-arm64)
                platform="ios"; arch="arm64-sim" ;;
              native_apple_ios-sim-x86_64)
                platform="ios"; arch="x86_64-sim" ;;
              native_android_arm64-v8a)
                platform="android"; arch="arm64" ;;
              native_android_x86_64)
                platform="android"; arch="x64" ;;
              *)
                echo "Skipping unknown artifact directory: $name"
                continue
                ;;
            esac

            while IFS= read -r src; do
              [ -n "$src" ] || continue
              base="$(basename "$src")"
              dst="$(rename_with_suffix "$base" "$platform" "$arch")"
              cp "$src" "release_assets/$dst"
            done < <(find "$dir" -maxdepth 1 -type f \( -name '*.dll' -o -name '*.dylib' -o -name '*.so' -o -name '*.so.*' \) | sort)
          done

          ls -la release_assets
          test -n "$(find release_assets -maxdepth 1 -type f -print -quit)"

      - name: Generate manifest + checksums
        run: |
          chmod +x scripts/generate_assets_manifest.sh
          scripts/generate_assets_manifest.sh \
            "${{ needs.resolve-tag.outputs.tag }}" \
            release_assets \
            release_assets/assets.json \
            release_assets/SHA256SUMS

      - name: Create release
        if: ${{ github.event.inputs.publish_release == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.resolve-tag.outputs.tag }}
          name: ${{ needs.resolve-tag.outputs.tag }}
          files: release_assets/*
          prerelease: false
